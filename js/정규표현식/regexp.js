/* 
[정규표현식 리터럴]

'/' 혹은 'new RegExp' 사용

*/

var pattern = /a/;
// console.log(pattern)
// 결과값 /a/

var pattern2 = new RegExp('a');
// console.log(pattern2)
// 결과값 /a/

//변수 패턴 1, 2는 같은 값을 출력한다.


/////////////////////////////////


/*
[정규표현식 메소드 실행]

1. RegExp.exec()
   = exec는 찾고자 하는 정보가 있다면 배열로 리턴, 찾고자 하는 정보가 없다면 null을 리턴한다.
   

2. RegExp.test()
    = test는 찾는 정보의 존재 유무에 따라 블리언 값으로 리턴한다.
*/



pattern.exec('abcde');
// console.log(pattern.exec('abcde'));
// console.log(new RegExp('a').exec('abcde')) = 정규표현식 메소드는 이런 방식으로도 사용할 수 있다.
// 결과값 ["a"]

var pattern3 = /a./;
// '.'은 문자 1개를 의미한다. 여기서는 문자 'a' 옆에 '.'을 둠으로써
// a라는 문자 옆에 1개의 문자를 같이 출력한다.

pattern3.exec('abcde');
// console.log(pattern3.exec('abcde'));
// 결과값 ["ab"]

pattern.test('abcde');
// console.log(pattern.test('abcde'));
// 결과값 true


pattern.test('bcde');
// console.log(pattern.test('bcde'));
// 결과값 false




/* 
    [문자열 메소드 실행]

    1. string.match()

    = exec와 유사한 기능을 수행한다. 문자열 내에 일치한 정보가 있다면 배열 리턴, 없으면 null 값을 리턴한다.

    2. string.replace(첫번째 인자, 두번째 인자)

    = 문자열 내 첫번째 인자로 받은 패턴과 일치한 문자를 두번째 인자로 받은 패턴으로 교체한다.


*/

var str = 'abcdef';

str.match(pattern);

// console.log(str.match(pattern))
// 결과값 ['a']

str.replace(pattern, 'A');
// console.log(str.replace(pattern, 'A'));
// 결과값 Abcdef

//////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
    [캐럿(^)]
    ^뒤에 오는 문자열로 시작하는 텍스트를 찾는다. 
    대괄호 안에 쓰는 캐럿은 not의 의미를 갖는다.
    유효성 검사에서 쓰임. 불리언 값을 찾을때

    [달러($)]
    캐럿과는 반대로 문자열 뒤에 붙는다. $ 기호는 해당 문자열로 끝나는 텍스트를 찾는다.
    유효성 검사에서 쓰임. 불리언 값을 찾을때

    [역슬래시(\)]

    \는 정규표현식에서 문자열로 취급하는 명령어다. (escape 기법이라 한다.)
*/


/^zonny117/.test('zonny117 is zonny');

// console.log(/^zonny117/.test('zonny117 is zonny'));
// 결과값 true, 문자열이 zonny117로 시작하기 때문이다.


/zonny117$/.test('zonny117 is zonny');

// console.log(/zonny117$/.test('zonny117 is zonny'));
// 결과값 false, 문자열이 zonny117이 아닌 zonny로 끝나기 때문이다.


/^$zonny117/.test('$zonny117 is zonny');
// $zonny117로 시작하는 문자열이 있는지 찾는 정규표현식을 짜려고 한다. 
// 캐럿을 넣고 그 뒤에 $zonny117을 넣었지만 이 문법은 null값을 리턴한다.
// 이유는 캐럿 뒤에 오는 달러 기호가 문자열이 아닌 기호로 인식되기 때문이다.

/^\$zonny117/.test('$zonny117 is zonny');
// 따라서 기호가 두개가 온다면 역슬래시를 이용해 달러를 escape를 시켜주고 
// 해당 달러 기호는 문자열로 취급하게 명령하면, $zonny117로 시작하는 문자열을 찾는다.


// console.log(/^\$zonny117/.test('$zonny117 is zonny'));
// 결과값 true


////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
    [모든 문자를 찾는 기호 닷(.)]
    닷은 대상 문자열 내 문자, 특수문자, 공백 할거 없이 모든 문자열을 포함해 찾는다. 
    닷의 개수에 따라 문자열 내 문자 개수가 출력된다.
*/

/..../.test('zonny117 is zonny');

// console.log(/..../.exec('zonny117 is zonny'))
// 결과값 [zonn] 문자열에서 4개(닷의 개수)의 문자만 출력된다.


/\......\./.exec('zonny is ... me.');
// zonny is ... me. 라는 문자열에서 ... me. 를 출력해 보겠다.
// ... me. 는 총 7개의 문자로 이루어진 문자열이다. (공백 포함).
// 시작 닷과 끝나는 닷을 제외하면 5개의 문자만 찾아오면 된다.
// 첫 닷과 끝 닷은 역슬래시로 문자라 취급하고 
// 역슬래시 사이에 5개의 닷 기호를 추가하면
// ... me. 가 출력된다.

// console.log(/\......\./.exec('zonny is ... me.'))
// 결과값 [... me.]

////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
    [대괄호([])]

    []는 대괄호 안에 있는 문자를 가지고 있는 문자열을 출력한다.
    대괄호 기호는 1개의 문자로 취급된다. 
    즉, [abc]는 1개의 문자 [abc][def]는 2개의 문자다.
    
    [범위 설정 Range]

    대시(-) 기호는 찾고자 하는 문자 범위를 지정해준다. 대괄호와 함께 쓴다. 대소문자를 구별한다.

    ex) 소문자 a에서 g까지 찾기 
    [a-g]

    ex) 대문자 a에서 g까지 찾기
    [A-G]

    ex) 숫자 1~9 찾기
    [1-9]


    대문자 A~G, 소문자 a~f, 숫자 1에서 5에 해당하는 문자열 찾기
    [A-Ga-f1-5]


    [캐럿(^)]

    대괄호 안에 쓰는 캐럿은 다른 not의 의미를 갖는다.
    찾는 문자열에서 설정한 문자열을 제외한 나머지를 찾게 한다.
    대소문자를 구분한다.

    ex) 소문자 a에서 g 제외
    [^a-g]
*/


/[zon]/.exec('zonny117 is zonny');
// console.log(/[zon]/.exec('zonny117 is zonny'));
// 결과값 [z] 문자 1개 출력


/[zon][zon]/.exec('zonny117 is zonny');
// console.log(/[zon][zon]/.exec('zonny117 is zonny'));
// 결과값 [zo] 문자 2개 출력

// console.log(/[o~y1~9].../.exec('zonny117 is zonny'));

////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
    [서브패턴]

    괄호()를 이용해 패턴 내부에서 또 다른 패턴을 정의할 수 있다.
    패턴의 개수는 파이프(|) 기호를 이용해 늘릴 수 있다.

    예) 문자열 내 on 혹은 fri 혹은 sun의 패턴을 가진 문자열을 찾는다.
    (on|fri|sun)

    예)

    
    
*/

// console.log(('monday, Friday, sunday').match(/(on|fri|sun)/))


/* 
    () 괄호는 그룹을 의미
    \w 문자를 의미 = A-Z, a-z, 0-9를 전부 포함한다.
    + 수량자 = 여기서는 \w와 함께 붙어서 1개 이상의 문자를 의미
*/

var gws = 'zonny 117'.replace(/(\w+)\s(\w+)/, "$2, $1");

// console.log(gws)
//  결과값 117, zonny

/*  
    $기호는 정규표현식의 한 그룹에 해당하는 패턴을 의미한다.
    $2는 두번째 그룹에 속하는 문자열, $1은 첫번째 그룹에 해당하는 문자열.
    그리고 중간에 콤마 공백이 하나씩 존재하기에
    즉, 117, zonny가 결과값이다.
*/

/* 
    전방 탐색 기호는 ?= 
    = 다음에 오는 문자가 일치하는 영역에서 제외

    후방 탐색의 기호는 ?<=
    전방 탐색 기호의 ?와 = 사이에 < 기호가 추가된 것


    ※하위 표현식과 같이 소괄호로 감싸주어야한다.

    부정형 탐색은 일치하지 않는 텍스트를 탐색

    부정형 전방 탐색 ?!
    부정형 후방 탐색 ?<!



    [수량자 *]
    a*b에서 *는 b앞에 a가 1개 이상 있거나 혹은 없는 패턴을 찾는 수량자 역할을 한다.
    * 뒤에 오는 문자를 기준으로 잡으면 이해하기 쉽다.

    [수량자 +]
    a+b에서 +는 1개 이상의 문자열을 찾는다. 즉, b앞에 아무 문자가 없으면 찾지 않고
    a문자가 1개라도 존재하면, 찾는다.

    [수량자 ?]
    a?b에서 ?는 b앞에 a라는 문자가 없거나 1개 있는 경우를 찾는다. 2개 이상은 찾지 않는다.

    [수량자 {}]
    [ab]{1,2} a나 b가 1개 이상 2개 이하까지 있는 패턴을 찾는다.
    [ab]{1,} 콤마 뒤에 아무런 값을 입력하지 않는 경우, 콤마 앞 숫자 이상에 해당하는 패턴을 찾는다. 여기서는 1개 이상




    [수량자 뒤에 ?가 오는 경우]
    수량자 뒤에 ?가 오면 해당 수량자는 뜻이 바뀌게 된다.

    예) 없거나 1개 이상의 문자를 찾는 *가 *?가 되면 0개 이상의 문자를 찾는 형태로 바뀐다. 
    r.*는 r로 시작하고 그 뒤에 없거나 1개 이상인 모든 문자를 포함한 문자열을 찾지만,
    r.*?는 r로 시작하고 그 뒤에 모든 문자가 0개인 문자열을 찾는 의미로 바뀐다.

    r.+?의 경우, 원래는 +가 1개 이상의 문자를 찾는 수량자이지만 뒤에 ?가 붙어서 1개만 찾는 의미로 변하게 된다.
    즉, r로 시작하며 그뒤에 모든 문자가 1개까지만 있는 문자열을 찾는다.

    r.??의 경우, 수량자 ?는 없거나 1개인 문자를 찾는데, 뒤에 ?가 붙어서 없는 문자만 찾는다.
    즉, r로 시작하며 그 뒤에 모든 문자가 없는 문자열을 찾는다.

    따라서, 수량자 뒤에 ?가 온다는 것은 해당 수량자가 최소 조건에 해당하는 문자만 찾도록 의미를 바꾼다는 뜻이다. 




    [탐욕적/게으른]

    그럼 위 ?는 어떤 경우에 쓰는가?
    예) A.*B라는 정규표현식이 있다. 
    A뒤에 모든 문자 형태가 없거나 1개 이상있으면 전부 일치시키며 뒤에 B가 오면 끝난다.

    A나는게으르다BA나는탐욕적이다B 라는 문자열이 있다. 
    위 정규표현식을 대입해보면, 첫번째 A부터 맨 마지막 B까지 전부 해당하는 문자열로 취급한다.
    
    만약, 첫번째에 만나는 B까지만 해당하는 문자열로 취급하고 싶다면, 
    A.*?B를 쓴다. A나는게으르다B 까지만 문자열을 추출한다.

    따라서, 최소 반복하는 문자열을 찾는 수량자는 게으른 수량자.
    최대 반복하는 문자열을 찾는 수량자는 탐욕적 수량자라 일컫는다.
*/

// 전방 탐색 1
/(?=\.).{1,}/g;

//전방 탐색 2
/.{1,}(?=\.)/g;

// 전방 탐색3
/(?=.*\.).{1,}/g;
/* 
    검색 문자열 
    naver.com



    
    위 검색 문자열에 전방 탐색1 정규 표현식을 대입해보면
    .com이 출력된다.

    ?=\.은 마침표를 기준으로 앞에 오는 문자열은 출력하지 않는다는 의미이고,
    .{1,}에서 어떤 문자던 1자리 이상을 찾아오게 한다.

    따라서 naver.com에서 마침표 앞에 naver는 출력하지 않는다는 것이고, 
    마침표를 기준으로 뒤쪽에 어떤 문자든 1자리 이상인 com은 출력된다.

    즉, .com이 결과값이다.


    반대로, 전방 탐색 2 정규표현식 같은 경우
    어떤 문자든 1개 이상이 먼저 오고, 그 뒤에 마침표 앞에 있는 문자열만 출력하겠다는 의미가 된다.

    naver.com에서 마침표 기준 뒷 문자열은 제외하고 마침표 앞 어떤 문자 1개 이상인 naver만 출력된다.

    즉, 전방탐색 기호 앞 검색 문자열 여부에 따라 출력하는 결과값이 다르다.


    전방 탐색 3의 경우

    (?=.*\.)은 마침표 기준으로 앞에 어떤 문자가 1개 이상 있거나 없든 상관하지 않고 전부 출력하라는 의미가 된다.
    따라서 naver.com에서 마침표 앞에 naver가 있든 없든 무조건 출력하게 된다.
    결과값은 naver.com

*/


// 비밀번호 패턴 분석
/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[$@$!%*?&])[A-Za-z\d$@$!%*?&]{8,16}/g;


/* 
    위 정규표현식은 비밀번호를 체크하는 식이다. 

    먼저, 소괄호로 따로 따로 묶여있는 전방탐색 그룹이 있다.

    (?=.*[a-z]) 소문자 앞에 문자가 없거나 1개 이상이 있든 앞에 있는 상관없다는 그룹이다.
    (?=.*[A-Z]) 이것은 대문자,
    (?=.*\d) 이건 숫자,
    (?=.*[$@$!%*?&]) 이건 특수문자인데, 대괄호 패턴안에 있는 특수문자만 해당된다.

    각각, 앞에 뭐가 오든 상관없다는 그룹들이다.
    주의할 점은 이 각각의 그룹에 해당하는 패턴들이 검색하고자 하는 문자열에 존재해야 작동한다는 것이다.
    
    즉, 검색 문자열에 소문자,대문자,숫자,특수문자가 전부 있어야된다는 뜻이다.
    
    또한, 각 그룹에서 앞에 어떤 문자가 오든 상관없다고 했으니 검색 문자열은 그룹에 해당하는
    패턴들이 무작위로 섞여있어도 상관없다는 것이다. 비밀번호를 여러 방식으로 조합할 수 있다는 것이다.

    [A-Za-z\d$@$!%*?&]{8,16} 은 최종적으로 앞에 그룹들이 실행이 가능하다 판단되면, 이 패턴에 해당하는 문자열을 출력하고,
    그것이 8자 이상 16자 이내여야 한다는 뜻이다.

    전방탐색 그룹만 존재하면 결과값은 받을 수 없다. 따라서 [A-Za-z\d$@$!%*?&]{8,16} 처럼 패턴을 지정해주어야한다.

    
    결과적으로 위 정규 표현식은 다음과 같다.

    소문자, 대문자, 숫자, 특수문자 조합 8 ~ 16자로 비밀번호를 작성할 수 있다.
*/